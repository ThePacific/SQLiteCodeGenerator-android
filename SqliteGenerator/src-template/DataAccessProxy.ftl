/**
 * =============================
 * Generated by SQLiteGenerator
 * Copyright (C) 2016 UsherBaby
 * =============================
 */

package ${api.javaPackage};

import android.content.Context;
import android.database.Cursor;
import android.database.DatabaseErrorHandler;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteTransactionListener;

import ${api.modelJavaPackage+"."+api.superModelClassName};

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ${api.dataAccessClassName} {

    private ${api.dbOpenHelperClassName} dbOpenHelper;

    /**
     * If you need to create a database file in sdcard, please use DBContext.
     */
    public ${api.dataAccessClassName}(Context context, String name, int version) {
        this(context, name, null, version);
    }

    public DataAccessProxy(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
        this(context, name, factory, version, null);
    }

    public ${api.dataAccessClassName}(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {
        dbOpenHelper = new ${api.dbOpenHelperClassName}(context, name, factory, version, errorHandler);
    }

    /**
     * @param cls   Type of Class.
     * @param where Query condition, <usage> "where name=?"</usage>
     * @param args  Query params, <usage> new String[]{"UsherBaby"}</usage>
     */
    public <T extends SuperModel> int getCount(Class<T> cls, String where, String[] args) {
        StringBuffer buffer = new StringBuffer("select count(*) from ");
        buffer.append(getTableName(cls));
        if (where != null && where.length() > 0) {
            buffer.append(" ");
            buffer.append(where);
        }
        buffer.append(";");
        Cursor cursor = rawQuery(buffer.toString(), args);
        if (cursor != null && cursor.moveToFirst()) {
            return cursor.getInt(0);
        }
        return 0;
    }

    /**
     * @param cls   Type of Class.
     * @param where Query condition, <usage> "where name=?"</usage>
     * @param args  Query params, <usage> new String[]{"UsherBaby"}</usage>
     */
    public <T extends SuperModel> List<T> load(Class<T> cls, String where, String[] args) {
        StringBuffer buffer = new StringBuffer("select * from ");
        buffer.append(getTableName(cls));
        if (where != null && where.length() > 0) {
            buffer.append(" ");
            buffer.append(where);
        }
        buffer.append(";");
        return query(cls, buffer.toString(), args);
    }

    /**
     * @param cls   Type of Class.
     * @param where Query condition, <usage> "where name=?"</usage>
     * @param args  Query params, <usage> new String[]{"UsherBaby"}</usage>
     */
    public <T extends SuperModel> boolean clear(Class<T> cls, String where, String[] args) {
        StringBuffer buffer = new StringBuffer("delete from ");
        buffer.append(getTableName(cls));
        if (where != null && where.length() > 0) {
            buffer.append(" ");
            buffer.append(where);
        }
        buffer.append(";");
        return execSQL(buffer.toString(), args);
    }

    /**
     * Insert a model.
     */
    public <T extends SuperModel> boolean insert(T model) {
        Object[] objects = model.getInsertSql();
        return execSQL(objects[0].toString(), Arrays.copyOfRange(objects, 1, objects.length));
    }

    /**
     * Delete a model.
     */
    public <T extends SuperModel> boolean delete(T model) {
        Object[] objects = model.getDeleteSql();
        return execSQL(objects[0].toString(), Arrays.copyOfRange(objects, 1, objects.length));
    }

    /**
     * Update a model.
     */
    public <T extends SuperModel> boolean update(T model) {
        Object[] objects = model.getUpdateSql();
        return execSQL(objects[0].toString(), Arrays.copyOfRange(objects, 1, objects.length));
    }

    /**
     * Query models.
     */
    public <T extends SuperModel> List<T> query(Class<T> cls, String sql, String[] selectionArgs) {
        Cursor cursor = rawQuery(sql, selectionArgs);
        if (cursor != null && cursor.moveToFirst()) {
            List<T> list = new ArrayList<>();
            do {
                try {
                    T model = cls.newInstance();
                    model.initValues(cursor);
                    list.add(model);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            } while (cursor.moveToNext());
            return list;
        }
        return null;
    }

    /**
     * Execute a SQL statement,usually for insert,delete,update,create,drop
     */
    public boolean execSQL(String sql, Object[] selectionArgs) {
        dbOpenHelper.getWritableDatabase().execSQL(sql, selectionArgs);
        return true;
    }

    /**
     * Execute a SQL statement,usually for query only
     */
    public Cursor rawQuery(String sql, String[] selectionArgs) {
        return dbOpenHelper.getReadableDatabase().rawQuery(sql, selectionArgs);
    }

    /**
     * Close the database connection,and release resource
     */
    public void release() {
        dbOpenHelper.close();
        dbOpenHelper = null;
    }

    /**
     * Begin a transaction
     */
    public void beginTransaction(SQLiteTransactionListener transactionListener, boolean exclusive) {
        if (exclusive) {
            dbOpenHelper.getWritableDatabase().beginTransactionWithListener(transactionListener);
        } else {
            dbOpenHelper.getWritableDatabase().beginTransactionWithListenerNonExclusive(transactionListener);
        }
    }

    /**
     * Returns true if the current thread has a transaction pending.
     */
    public boolean inTransaction() {
        return dbOpenHelper.getWritableDatabase().inTransaction();
    }

    /**
     * Set transaction successful state
     */
    public void setTransactionSuccessful() {
        dbOpenHelper.getReadableDatabase().setTransactionSuccessful();
    }

    /**
     * End a transaction
     */
    public void endTransaction() {
        dbOpenHelper.getWritableDatabase().endTransaction();
    }

    protected <T extends SuperModel> String getTableName(Class<T> cls) {
        try {
            return cls.newInstance().getTableName();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}